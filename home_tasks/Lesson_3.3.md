# Lesson 3.3

### 1. Какой системный вызов делает команда cd? 
`chdir("/tmp") = 0`

### 2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
`openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`

### 3. Предложите способ обнуления открытого удаленного файла
```shell
sudo lsof | grep <deleted_file> # Находим номер процесса по удаленному файлу
MY_PROC=<PID> # Для удобства записываем PID в переменную
sudo ls -l /proc/$MY_PROC/fd # Находим номер дескриптора пишущего в файл, на примере следующей строки:
l-wx------ 1 vagrant vagrant 64 Sep 10 08:12 3 -> '/home/vagrant/test_fs/logs/logs.txt (deleted)'
MY_PROC_DESC=<number_of_descriptor> # Записываем в переменную номер дескриптора
cat /dev/null > sudo tee /proc/$MY_PROC/fd/$MY_PROC_DESC # Обнуляем файл
```
P.S. В идеале для работы скрипта нужно ещё автоматизировать создание переменных (распарить `stdout` для получения значения) `MY_PROC` и `MY_PROC_DESC`, но этого точно в д.з. не было =).

### 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Поскольку `зомби-процесс` является завершенным, то можно сказать, что он не тратит ресурсы:
- CPU - процесс завершен выполнять нечего
- RAM - процесс завершен и выгружен из памяти, за исключением записи в талице процессов
- IO - поскольку процесс завершен, то соответственно он нечего не считывает и нечего не выводит

но (цитирую википедию =) ):
> Зомби-процессы блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом. 
> При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы.

### 5. На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты `opensnoop`?
```shell
sudo apt install bpfcc-tools linux-headers-$(uname -r)
sudo /usr/sbin/opensnoop-bpfcc -d 1

PID    COMM           FD ERR PATH
797    vminfo         4   0 /var/run/utmp
601    dbus-daemon   -1   2 /usr/local/share/dbus-1/system-services
601    dbus-daemon   18   0 /usr/share/dbus-1/system-services
601    dbus-daemon   -1   2 /lib/dbus-1/system-services
601    dbus-daemon   18   0 /var/lib/snapd/dbus-1/system-services/
```

### 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
`uname()`
> Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.

### 7. Чем отличается последовательность команд через `;` и через `&&` в bash? Есть ли смысл использовать в bash `&&`, если применить `set -e`?
- `&&` - Первая команда исполняется всегда, вторая — только в случае успешного завершения первой
- `;` - Команды исполняются всегда

Если сначала использовать `set -e`, то в использование `&&` нет смысла, т.к. конструкция `set -e` остановит скрипт в случае возврата кода ошибки. Пример скрипта для теста:
```shell
#!/bin/bash

set -e

function test_1() {
    echo "TEST 1"
    return 1
}

function test_2() {
    echo "TEST 2"
    return 0
}

function test_3() {
    echo "TEST 3"
    return 0
}

test_1
test_2
test_3
```
На экран выведется только 'TEST 1'

### 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
- `e` - Остановит выполнение скрипта в случае вывода ошибки
- `u` - Обрабатывать несуществующие переменные как ошибки
- `x` - Печатать трассировку команд после их запуска и до их выполнения
- `o` - Устаналивает или снимает опцию по её длинному имени
- `pipefail` - Предотвращает маскировку ошибок в конвейере. Если какая-то команда завершится с ошибкой, то эта ошибка будет использоваться как код возврата всего конвейера

Набор этих опций очень полезен при разработке т.к. позволяет отлавливать ошибки и останавливать работу скрипта в случае их появления.

### 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. Что значат дополнительные к основной заглавной буквы статуса процессов
```shell
ps -o stat
Ss # Sleeping
R+ # Running
```
- `<` - высокий приоритет (не нравится другим пользователям)
- `N` - низкий приоритет (приятный для других пользователей)
- `L` - имеет страницы, заблокированные в памяти (в режиме реального времени и пользовательского IO)
- `s` - является лидером сессии
- `l` - является многопоточным
- `+` - находится в группе процессов переднего плана
