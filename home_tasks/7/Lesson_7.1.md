# Lesson 6.6

### 1. Зависшая операция `CRUD` в `MongoDB`
Узнаём `opid` операции, которую хотим "Убить".
```
use admin
db.aggregate( [
   { $currentOp : { allUsers: true, localOps: true } },
   { $match : <filter condition> }
] )
```
Если операции на `чтение`, тогда достаточно выполнить следующую команду
```
db.killOp(<opid of the query to kill>)
```
Если операции на `запись`, тогда придется "убить" сессию
```
db.adminCommand( { killSessions: [
   { "id" : UUID("80e48c5a-f7fb-4541-8ac0-9e3a1ed224a4"), "uid" : BinData(0,"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=") }
] } )
```

Во избежание в дальнейшем долгих зависающих запросов, необходимо разобраться в природе их зависания. Например, мы можем вычислить проблемные запросы следующей командой.
```
db.currentOp({"secs_running":{$gte:5}})
```
Можем проанализировать конкретный запрос 
```
db.inventory.find(
    { quantity: { $gte: 100, $lte: 200 } }
).explain("executionStats")
```
А также необходимо включить мониторинг
```
db.enableFreeMonitoring()
```
На крайний случай мы можем ограничить время выполнения запросов
```
maxTimeMS()
```

### 2. Проблемы с `Redis`
Исходя из сложившейся ситуации и официальной документации можно предположить, что проблема связанна с созданием форков. Эта процедура является ресурсоёмкой и требует время ны выполнение, особенно на слабом "железе".

### 3. `InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '` в `MySQL`
Эта ошибка может возникнуть по нескольким причинам:
* проблема с сетевой доступностью
* передача большого количества данных в запросе не укладывается в `net_read_timeout`
* подключение не уложилось в `connect_timeout`

После проверки сети можно сделать следующее:
В случае если мы превысили максимально разрешенное количество передаваемых пакетов, тогда следует увеличить параметр `max_allowed_packet`.
Как мы видим происходит запрос `SELECT`. Нужно посмотреть таблицу(ы) в которую(ые) идет запрос. Целы ли таблицы и как много в них данных? 
Если проблема в больших данных, то можно попробовать разбить запрос на более мелкие и проанализировать их с помощью команды `EXPLAIN`, а также шардировать таблицу. 
Возможно потребуется увеличение аппаратных ресурсов ноды.

### 4. `postmaster invoked oom-killer` в `PostgreSQL`
Как известно `oom-killer` штука коварная и убивает процессы, которые по еге мнению потребляют больше ресурсов чем дозволенно, ни кого не спрашивая =).
Можно ограничить количество потребляемой памяти средствами ОС (`cgroups`, `ulimit` и т.д.). Возможно потребуется увеличить объем оперативной памяти на ноде.